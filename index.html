<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Runner - Session 12</title>
<style>
  body { margin: 0; overflow: hidden; }
  #score {
    position: absolute;
    top: 12px;
    left: 12px;
    font-size: 24px;
    color: #fff;
    z-index: 10;
  }
</style>
</head>
<body>

<div id="score">Score: 0</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
/* ================= SCENE & CAMERA ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x111111, 10, 60);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0,5,10);

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ================= LIGHTS ================= */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffffff,0.8);
sunLight.position.set(0,20,0);
scene.add(sunLight);

/* ================= SKY ================= */
let sky = new THREE.Mesh(
  new THREE.SphereGeometry(100,32,32),
  new THREE.MeshBasicMaterial({color:0x87CEEB, side: THREE.BackSide})
);
scene.add(sky);

/* ================= CLOUDS ================= */
const cloudGeo = new THREE.SphereGeometry(1,12,12);
const cloudMat = new THREE.MeshStandardMaterial({color:0xffffff,transparent:true,opacity:0.7});
const clouds = [];
for(let i=0;i<20;i++){
  const cloud = new THREE.Mesh(cloudGeo,cloudMat);
  cloud.position.set((Math.random()-0.5)*60, 10+Math.random()*10, -50-Math.random()*50);
  cloud.scale.set(2+Math.random()*3,1+Math.random(),1+Math.random()*2);
  scene.add(cloud);
  clouds.push(cloud);
}

/* ================= ROAD TILES ================= */
const roadWidth = 6;
const roadLength = 50;
const roadTiles = [];
function createRoadTile(z){
  const geo = new THREE.PlaneGeometry(roadWidth,roadLength);
  const mat = new THREE.MeshStandardMaterial({color:0x228B22}); // green ground
  const tile = new THREE.Mesh(geo,mat);
  tile.rotation.x=-Math.PI/2;
  tile.position.z=z;
  scene.add(tile);
  roadTiles.push(tile);
}
for(let i=0;i<4;i++) createRoadTile(-i*roadLength);

/* ================= LANES ================= */
const lanePositions = [-2,0,2];
lanePositions.forEach(x=>{
  const geo = new THREE.PlaneGeometry(0.1,200);
  const mat = new THREE.MeshBasicMaterial({color:0xffffff});
  const line = new THREE.Mesh(geo,mat);
  line.rotation.x=-Math.PI/2;
  line.position.set(x,0.01,-50);
  scene.add(line);
});

/* ================= PLAYER CAR ================= */
let playerLane = 1;
const input = {left:false,right:false};
let car;

const loader = new THREE.GLTFLoader();
loader.load(
  'https://models.babylonjs.com/CesiumMilkTruck.glb',
  gltf=>{
    car = gltf.scene;
    car.scale.set(0.01,0.01,0.01);
    car.position.set(0,0,2);
    scene.add(car);
  }
);

/* ================= JUMP ================= */
let isJumping = false;
let velocityY = 0;
const gravity=-0.02;
const jumpStrength=0.5;

/* ================= OBSTACLES & COINS ================= */
let obstacles=[], coins=[], dustParticles=[];
let score=0, gameSpeed=0.3;
function spawnObstacle(){
  const lane = Math.floor(Math.random()*3);
  const geo = new THREE.BoxGeometry(1,0.5,2);
  const mat = new THREE.MeshStandardMaterial({color:0xff0000});
  const obs = new THREE.Mesh(geo,mat);
  obs.position.set(lanePositions[lane],0.25,-60);
  scene.add(obs);
  obstacles.push({mesh:obs,lane});
}
function spawnCoin(){
  const lane = Math.floor(Math.random()*3);
  const geo = new THREE.SphereGeometry(0.3,12,12);
  const mat = new THREE.MeshStandardMaterial({color:0xffff00});
  const coin = new THREE.Mesh(geo,mat);
  coin.position.set(lanePositions[lane],0.25,-60);
  scene.add(coin);
  coins.push({mesh:coin,lane});
}

/* ================= INPUT ================= */
window.addEventListener("keydown",e=>{
  if(e.code==="ArrowLeft") input.left=true;
  if(e.code==="ArrowRight") input.right=true;
  if(e.code==="Space" && !isJumping){ isJumping=true; velocityY=jumpStrength; }
});
let startX=null;
window.addEventListener("touchstart",e=>startX=e.touches[0].clientX);
window.addEventListener("touchend",e=>{
  const dx = e.changedTouches[0].clientX-startX;
  if(dx>40) input.right=true;
  if(dx<-40) input.left=true;
  if(Math.abs(dx)<10 && !isJumping){ isJumping=true; velocityY=jumpStrength; }
});

/* ================= GAME LOOP ================= */
let timeOfDay = 0; // 0-1 = day-night
function animate(){
  requestAnimationFrame(animate);
  if(!car){ renderer.render(scene,camera); return; }

  // Lane switching
  if(input.left){ playerLane=Math.max(0,playerLane-1); input.left=false; }
  if(input.right){ playerLane=Math.min(2,playerLane+1); input.right=false; }
  const targetX = lanePositions[playerLane];
  car.position.x += (targetX - car.position.x)*0.3;

  // Jump physics
  velocityY += gravity;
  car.position.y += velocityY;
  if(car.position.y<=0){ car.position.y=0; velocityY=0; isJumping=false; }

  // Dust trail
  const dustGeo = new THREE.SphereGeometry(0.05,6,6);
  const dustMat = new THREE.MeshBasicMaterial({color:0xaaaaaa,transparent:true,opacity:0.5});
  const p = new THREE.Mesh(dustGeo,dustMat);
  p.position.set(car.position.x,0.1,car.position.z-1);
  scene.add(p);
  dustParticles.push(p);
  dustParticles.forEach((d,i)=>{
    d.position.z -= gameSpeed;
    d.material.opacity -=0.02;
    if(d.material.opacity<=0){ scene.remove(d); dustParticles.splice(i,1); }
  });

  // Road tiles
  roadTiles.forEach(tile=>{
    tile.position.z+=gameSpeed;
    if(tile.position.z>roadLength/2) tile.position.z-=roadLength*roadTiles.length;
  });

  // Obstacles
  obstacles.forEach((o,i)=>{
    o.mesh.position.z+=gameSpeed;
    if(o.mesh.position.z>5){ scene.remove(o.mesh); obstacles.splice(i,1); }
    if(Math.abs(car.position.z-o.mesh.position.z)<1.5 &&
       Math.abs(car.position.x-o.mesh.position.x)<1.2 &&
       car.position.y<=0.25){
         velocityY=0.3; alert("Crashed! Score: "+score);
         window.location.reload();
       }
  });

  // Coins
  coins.forEach((c,i)=>{
    c.mesh.position.z+=gameSpeed;
    if(c.mesh.position.z>5){ scene.remove(c.mesh); coins.splice(i,1); }
    if(Math.abs(car.position.z-c.mesh.position.z)<1.5 &&
       Math.abs(car.position.x-c.mesh.position.x)<1.2){
         score+=10;
         document.getElementById("score").innerText="Score: "+score;
         scene.remove(c.mesh);
         coins.splice(i,1);
       }
  });

  // Camera follow
  camera.position.x += (car.position.x - camera.position.x)*0.05;
  camera.lookAt(car.position.x, car.position.y + 2, car.position.z);

  // Clouds
  clouds.forEach(c=>c.position.x += 0.01);

  // Day-night cycle
  timeOfDay += 0.0002; if(timeOfDay>1) timeOfDay=0;
  const skyColor = new THREE.Color().lerpColors(new THREE.Color(0x001848), new THREE.Color(0x87CEEB), Math.sin(timeOfDay*Math.PI));
  sky.material.color.copy(skyColor);
  ambientLight.intensity = 0.4 + 0.6*Math.sin(timeOfDay*Math.PI);
  sunLight.intensity = 0.3 + 0.7*Math.sin(timeOfDay*Math.PI);
  sunLight.position.y = 20*Math.sin(timeOfDay*Math.PI);
  sunLight.position.x = 20*Math.cos(timeOfDay*Math.PI);

  gameSpeed += 0.00005;

  renderer.render(scene,camera);
}

animate();

/* ================= SPAWN INTERVALS ================= */
setInterval(spawnObstacle,1500);
setInterval(spawnCoin,1000);

/* ================= RESIZE ================= */
window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>ï¿¼Enter
